<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>常见的闭包</title>

    <script type="text/javascript">

        /**
         * 
         *  ① 将函数作为另一个函数的返回值
         * 
        */

        // 1. 将函数作为另一个函数的返回值
        function fn1() {
            var a = 2;
            function fn2() {
                a++;
                console.log(a);
            }
            return fn2;
        }
        var f = fn1();
        f(); // 3
        f(); // 4

        //==========================================================================

        /**
         * 
         *  ② 将函数作为实参传递给另一个函数调用
         * 
         * */
        // 2. 将函数作为实参传递给另一个函数调用
        function showDelay(msg, time) {
            setTimeout(function () {
                alert(msg);
            }, time);
        };
        showDelay('atguigu', 2000);

        //===========================================================================

 
        /**
         * 
         *  ③ 高阶函数与柯里化
         *  - 有时候闭包在你甚至没有注意到它的时候就会出现，你可能已经看到了我们称为部分应用程序的示例
         * 
        */

        // 1、从 ES6 高阶箭头函数理解函数柯里化(运用到闭包)

        // 首先看到了这样的一个例子：
        let add = a => b => a + b;

        // 以上是一个很简单的相加函数，把它转化成 ES5 的写法如下
        function add(a) {
            return function (b) {
                return a + b;
            }
        }

        var add3 = add(3) //add3表示一个指向函数的变量 可以当成函数调用名来用
        add3(4) === 3 + 4 //true



        // 再简化一下，可以写成如下形式：
        // let add = function (a) {
        //     var param = a;
        //     var innerFun = function (b) {
        //         return param + b;
        //     }
        //     return innerFun;
        // }

        // 虽然好像没什么意义，但是很显然上述使用了[闭包]，而且该函数的返回值是一个函数。其实，这就是高阶函数的定义：以函数为参数或者返回值是函数的函数。


        // =========================================================================
        // 2、柯里化

        // 1. 图例: 参考(image- > "闭包" folder - > 柯里化图例)

        /**
         * 
         * 2. 关键就是理解柯里化，其实可以把它理解成，柯里化后，将第一个参数变量存在函数里面了(闭包)，
         *    然后本来需要n个参数的函数可以变成只需要剩下的（n - 1个）参数就可以调用，比如
         * 
         * 
        */
        // let add = x => y => x + y
        // let add2 = add(2);
        //* ----------------------------------
        // 本来完成 add 这个操作，应该是这样调用
        // let add = (x, y) => x + y;
        // add(2, 3);
        // // ----------------------------------
        // // 1. 而现在 add2 函数完成同样操作只需要一个参数，这在函数式编程中广泛应用。
        // let add = x => y => x + y;
        // let add2 = add(2);
        // // 2.详细解释一下，就是 add2 函数 等价于 有了 x 这个闭包变量的 y => x + y 函数, 并且此时 x = 2，所以此时调用
        // add2(3) === 2 + 3;



        /**
         * 
         *  3. 总结
         * 
         *  i. 如果是a => b => c => {xxx}这种多次柯里化的,如何理解?
         *      - 理解:前n - 1次调用，其实是提前将参数传递进去，并没有调用最内层函数体，最后一次调用才会调用最内层函数体，并返回最内层函数体的返回值
         * 
         *  ii. 结合上文可知，这里的多个连续箭头（无论俩个箭头函数三个及以上）函数连在一起 就是在柯里化。所以连续箭头函数就是多次柯里化函数的 es6 写法。
         * 
         *  iii. 调用特点:let test = a => b => c => {xxx}
         *      - 比如对于上面的 test 函数，它有 3 个箭头， 这个函数要被调用 3 次 test(a)(b)(c)，
         *        前两次调用只是在传递参数，只有最后依次调用才会返回 {xxx} 代码段的返回值，并且在 {xxx} 代码段中可以调用 a
         * 
        */








    </script>
</head>

<body>




</body>

</html>